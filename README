+++ jobim

An actors library for Clojure modelled after Erlang OTP plaform.


++ External dependencies

Jobim depends on RabbitMQ 2.X for dispatching messages between JVM
nodes. RabbitMQ is reliable, high performant messaging solution, supporting the
0.9 version of the AMQP messaging protocol, built on top of Erlang's OTP
platform.
I've been using in my day to day work Rabbit for several months and is one of
the best alternatives you can find to build a message queue.

Jobim also has a dependency on Apache's ZooKeeper. ZooKeeper is a really
impressive software that in the purest UNIX tradition does only one thing but
does it in the best possible way. In this case Zookeeper allows a set of
distributed processes to manage a shared tree of nodes and get notification
whenever this tree is modified by other processes. This basic functionality
provides out of the box support to use ZooKeeper as a powerful directory service
as well as a group membership service. It can also be extended to provide a whole
bunch of high level coordination services like priority queues or 2 phase commit
protocols.

++ Turning the JVM into a Node

Jobim agents need to be executed in a JVM that is executing a Node service. JVM
nodes are aware of the existence of other nodes, can exchange messages and
coordinate their activities.

A node service can be started in the JVM using a single function
<code>jobim/bootstrap-node</code>. This function receives as a parameter, a path
to a configuration file where the name of the node as well as the connection
options to RabbitMQ and ZooKeeper must be stated.

The following is a sample configuration file:

<pre>
;; Default configuration for a node

{:node-name "linux"

 ;; rabbit host, port, username, password and virtual host
 :rabbit-options [:host "192.168.1.35"]

 ;; zookeeper options:
 ;; servers: array of zk servers specified as host:port
 ;; timeout : session timeout
 ;; id : session id
 ;; password
 :zookeeper-options ["192.168.1.35:2181" {:timeout 3000}]}
</pre>


Once we have started the node, we should be able to use the
<code>jobim/nodes</code> function to check all the available nodes and their
identifiers:

<pre>
=> (use 'jobim)
nil
=> (bootstrap-node "node-config.clj")
"6811651bd83e4d428359b419e7f76a75"
=> (nodes)
{"osx" "5299491ea4184c02ad8c0fbc100c49f9", "linux" "6811651bd83e4d428359b419e7f76a75"}
</pre>

Nodes are aware of changes in the list of available nodes. They are also notified about
shutdown of nodes or about nodes not being reachable due to network partitions.

++ Creating an agent

A Jobim agent can be started using any Clojure function. This function can use
two special functions: <code>send!</code> and <code>receive</code> to send and
receive messages from other agents in the same node or in a different node.
In order to send a message, the agent needs to know the PID of the agent
receiving the message. This PID is passed as the first argument of the
<code>send!</code> function. The payload of the message is the second argument.

One agent can retrieve its own PID using the <code>jobim/self</code> function.

This is an implementation of a sample ping agent:

<pre>
(defn ping
  ([]
     (loop [continue true
            msg (receive)]
       (cond-match
        [#"exit" msg]       (recur false msg)
        [#"exception" msg]  (throw (Exception.
                                     (str "Ping actor with PID:"
                                          (self)
                                          "received exception")))
        [[?from ?data] msg] (do (send! from data)
                                (recur true (receive)))))))
</pre>

The implementation shown above uses <a href="http://spin.atomicobject.com/2010/04/25/matchure-serious-clojure-pattern-matching">Matchure</a> pattern matching library to
provide a more "erlang-like" experience.


To start the execution of a concurrent actor, the <code>jobim/spawn</code>
function can be used. it accepts a function or a string with the qualified
name of a function.

The <code>jobim/spawn</code> function returns the PID of the newly created
process or throws an exception if the creation went wrong.

<pre>
=> (def *pid* (spawn examples/ping))
#'clojure.core/*pid*
=> *pid*
"5299491ea4184c02ad8c0fbc100c49f9.1"
</pre>

The REPL or any other thread can be transformed into an agent using the
<code>spawn-in-repl</code> function. We will use this function to send some
messages to the ping agent we just created:

<pre>
=> (spawn-in-repl)
"5299491ea4184c02ad8c0fbc100c49f9.2"
=> (send! *pid* [(self) 13123])
:ok
=> (receive)
13123
</pre>


++ Messages payload

Jobim uses standard Java serialization mechanism to build the payload of the
messages. This means that whatever object implementing
<code>java.io.Serializable</code> can be send inside of a message.

For instance, we can send <code>Date</code> objects to our ping agent:

<pre>
=> (send! *pid* [(self) (java.util.Date.)])
:ok
=> (receive)
#<Date Fri Sep 03 13:20:26 CEST 2010>
</pre>

It is possible to change the serialization and deserialization mechanism used by
a node altering the <code>jobim.core/default-encode</code> and
<code>jobim.core/default.decode</code> symbols with suitable functions.

++ Going distributed

The most basic building block for distributed computing in Jobim is the
<code>jobim/rpc-call<code> function. This function receives a node identifier, a
string containing a function and an array of arguments and tries the invocation
of that function in the remote node.<code>rpc-call</code> returns inmediately
without knowing the result of the invocation in the remote node. If we want to
retrieve the result of the invocation we can use the blocking variant:
<code>jobim/rpc-blocking-call<code> that blocks until the result is returned or
an exception is launched.

RPC functions in Jobim accepts node identifiers, we can transform the name of a
node, maybe already retrieved with the <code>jobim/nodes</code> function into a
node identifier, using the <code>jobim/resolve-node-name</code> function.

The following example is a RPC call to do a simple addition:

<pre>
=> (nodes)
{"osx" "5299491ea4184c02ad8c0fbc100c49f9", "linux" "6811651bd83e4d428359b419e7f76a75"}
=> (resolve-node-name "linux")
"6811651bd83e4d428359b419e7f76a75"
=> (rpc-blocking-call (resolve-node-name "linux") "clojure.core/+" [1 2 3 4 5])
15
</pre>


One specially important use of the RPC functions is to start new agents in other
nodes invoking the <code>jobim/spawn</code> function remotely. If we use the
blocking variant of the the RPC function, we will retrieve the PID of the remote
agent and we could start sending messages to it:

<pre>
=> (def *pid* (rpc-blocking-call (resolve-node-name "linux") "jobim/spawn" ["jobim.examples.actors/ping"]))
#'clojure.core/*pid*
=> *pid*
"6811651bd83e4d428359b419e7f76a75.1"
=> (send! *pid* [(self) 345])
nil
=> (receive)
345
</pre>


++ Publishing processes

As long as we have the PID of an actor, we will be able to exchange messages
with it. Besides, since the PID is just a string, we can pass the PIDs inside
messages allowing actors to be "mobile actors" in a Pi-Calculus sense.

Nevertheless, it is sometimes convenient to be able to query for an actor using
a constant reference, for instance an alias, we know beforehand, so we can
communicate with the actor without needing to know its PID.

Jobim supports this use case with the <code>jobim/register-name</code>
function. Using this function, we can provide a name for the PID of a process
that will be globally available to all nodes in the system.

Registered names can be queried using the <code>jobim/registered-name</code>
function in a similar way to the <code>jobim/nodes</code> function for node
names and node identifiers.

We can transform a registered name into an actor PID using the
<code>jobim/resolve-name</code> function, so we can pass it as an argument in
<code>jobim/send!</code> function calls.

<pre>
=> (def *ping* (spawn examples/ping))
#'clojure.core/*ping*
=> *ping*
"5299491ea4184c02ad8c0fbc100c49f9.8"
=> (register-name "ping" *ping*)
:ok
=> (registered-names)
{"ping" "5299491ea4184c02ad8c0fbc100c49f9.8"}
=> (resolve-name "ping")
"5299491ea4184c02ad8c0fbc100c49f9.8"
=> (send! (resolve-name "ping") [(self) 1234])
:ok
=> (receive)
1234
</pre>


++ When things go wrong

Erlang systems have a very particular approach to error handling that consists of
not preventing failures but reacting quickly after a failure happens, most of
the time, restarting the failing component.

The basic mechanism behind this approach is the "linking" of processes. When two
Erlang processes are linked, any failure in one of the two process will produce
a fail signal in the other process that, if not properly handled, will cause the
other process to fail.

Special processes, known as supervisors, take care of creating and linking to
children processes as well as handling exceptions in the children according to some
kind of recovery policy.

Distributed Erlang applications are usually arranged as trees of processes where the
process at a node handle the error in the leafs of that node, and if is not able
to recover from that error, dies and bubble the error to the upper level.

Jobim provides limited support for this style of error handling with the
<code>jobim/link</code> function. The link function receives the PID of an actor
as an argument and links bidirectionally both actors.

From this point on, any error in one actor or a node down in the node where one
of the actors is running  will produce a special message signaling the error in
the other agent.

</pre>
=> (self)
"5299491ea4184c02ad8c0fbc100c49f9.1"
=> (def *pid* (spawn examples/ping))
#'clojure.core/*pid*
=> (link *pid*)
{"5299491ea4184c02ad8c0fbc100c49f9.1" ["5299491ea4184c02ad8c0fbc100c49f9.9"],
"5299491ea4184c02ad8c0fbc100c49f9.9" ["5299491ea4184c02ad8c0fbc100c49f9.1"]}
=> ; the ping actor will throw an exception if receives a message containing the
"exception" string
=> (send! *pid* "exception")
:ok
=> (receive)
{:signal :link-broken, :from "5299491ea4184c02ad8c0fbc100c49f9.9", :cause "class java.lang.Exception:Ping actor received exception"}
</pre>

This means that linked processes in Jobim must explicitly look for this kind of
messages and handle them, maybe throwing an exception, to obtain a similar
behaviour to OTP applications.

++ Evented actors

The actors introduced so far are executed  in their own Java thread. This is a
huge problem since a JVM will start throwing <code>OutOfMemory</code> exceptions
after a few thousands of threads are created.

On the other hand, Erlang systems can handle millions of concurrent actors in a single node, using
a preemptive scheduler that applies a fixed number of reductions in each Erlang
process being executed. This means that Erlang processes are extremely
lightweight and can be benefit from features like the linking of processes
previously discussed.

A possible alternative for building systems using a large amount of actors is to
use "evented actors" so a single java thread can execute different actors. This
solution has been <a href="http://www.scala-lang.org/node/242">explored in
Scala actors</a>.

Jobim evented actors rely on three special functions: <code>jobim/react</code> that is
equivalent to the <code>receive</code> funtion of a regular actor,
<code>jobim/react-loop</code> that creates a recursive evented actor and
<code>jobim/spawn-evented</code> that creates a new evented actor returning its
PID. This PID can be used with the regular <code>jobim/send!</code> function to
send messages to the evented actor.


The following is an evented implementation of the previously defined ping actor:

<pre>
(defn ping-evented
  ([]
     (let [name "test evented"]
       (react-loop
        (react
         (fn [msg]
           (cond-match
            [#"exit" msg]       false
            [#"exception" msg]  (throw (Exception. "Ping actor received exception"))
            [[?from ?data] msg] (send! from (str "actor " name " says " data)))))))))
</pre>

## License

Copyright (C) 2010 Antonio Garrote

Distributed under the Eclipse Public License, the same as Clojure.
